"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.registerOpenWithRecordCallback = registerOpenWithRecordCallback;
exports.OpenWithRecord = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _error_utils = require("./error_utils");

var _get_sdk = _interopRequireDefault(require("./get_sdk"));

/**
 * This class exists to manage registering a callback to receive "Open with record" messages.
 * This is different to other message handlers (_registerHandlers) since the callback is specified
 * by the block: it registers it during first render (vs the SDK registering during initialisation).
 *
 * On the liveapp side, we ensure that pending messages are held until the block registers the
 * callback (or another message is sent).
 *
 * In the SDK, we only allow one callback to be registered at a time. This is both for
 * simplicity (only your highest level component should handle it) as well as to avoid race
 * conditions where you have multiple handlers, and the message is sent while not all of them
 * have finished registering. We throw if multiple callbacks are registered.
 *
 * However, we do support unregistering the callback. This is to support cleaning up the callback
 * if the component is unmounted for some reason (otherwise we'd throw when the component is
 * mounted again).
 *
 * We handle unregistration at this layer (rather than the AirtableInterface layer): this adds
 * a level of indirection (the handler we register with airtableInterface calls the callback
 * stored in this class, rather than registering the callback as the handler) for a few reasons:
 * - simplifies subscription - we only register a handler with liveapp once, rather than registering
 *   and unregistering different callbacks
 * - simplifies unsubscription - don't need to add an unregister function to AirtableInterface
 *
 * This class is internal: users should use registerOpenWithRecordCallback or useOpenWithRecord.
 *
 * @internal
 * */
var OpenWithRecord =
/*#__PURE__*/
function () {
  /** @internal */

  /** @internal */

  /** @internal */

  /** @hidden */
  function OpenWithRecord(airtableInterface) {
    (0, _classCallCheck2.default)(this, OpenWithRecord);
    (0, _defineProperty2.default)(this, "_airtableInterface", void 0);
    (0, _defineProperty2.default)(this, "_hasRegisteredHandler", void 0);
    (0, _defineProperty2.default)(this, "_callback", void 0);
    this._airtableInterface = airtableInterface;
    this._hasRegisteredHandler = false;
    this._callback = null;
    this._handleOpenWithRecord = this._handleOpenWithRecord.bind(this);
  }
  /** @hidden */


  (0, _createClass2.default)(OpenWithRecord, [{
    key: "_handleOpenWithRecord",
    value: function _handleOpenWithRecord(data) {
      if (this._callback) {
        this._callback(data);
      }
    }
    /** @hidden */

  }, {
    key: "registerCallback",
    value: function registerCallback(callback) {
      if (this._callback) {
        throw (0, _error_utils.spawnError)('Cannot call registerCallback with a callback already registered');
      }

      this._callback = callback;

      if (!this._hasRegisteredHandler) {
        // If this is the first time a callback has been registered, we also need to register
        // a handler with airtableInterface to let liveapp know we can receive openWithRecord
        // messages and to handle those messages.
        // TODO(emma); dunno if register needs to be async / registerCallback should be async
        this._airtableInterface.registerOpenWithRecordHandlerAsync(this._handleOpenWithRecord);

        this._hasRegisteredHandler = true;
      }

      return () => {
        // Note: we don't unregister the handler for simplicity.
        // Since there's only one callback registered at a time, the unsubscribe function
        // simply clears it..
        this._callback = null;
      };
    }
  }]);
  return OpenWithRecord;
}();
/**
 * Registers a callback to handle "open with record" events (from button field).
 *
 * Your block will not receive "open with record" events until a callback is registered.
 *
 * Returns a unsubscribe function that can be used to unregister the callback (e.g. on
 * component unmount for cleanup, or if you wish to register a different function.)
 *
 * Only one callback can be registered at a time. It should ideally be registered from the top-level
 * component of your block.
 *
 * @hidden
 */


exports.OpenWithRecord = OpenWithRecord;

function registerOpenWithRecordCallback(callback) {
  var _getSdk = (0, _get_sdk.default)(),
      openWithRecord = _getSdk.openWithRecord;

  return openWithRecord.registerCallback(callback);
}